# 面向对象
面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定
+ 通过使用数据抽象，可以将类的接口与实现分离
+ 使用继承，可以定义相似的类型并对其相似关系建模
+ 使用动态绑定，可以在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象
## 继承
通过继承(inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部有一个
基类(base class)，其他类直接或间接地从基类继承而来，这些继承得到的类称为派生类(derived class)
基类负责定义在层次关系中所有类共同拥有的成员，每个派生类定义各自特有的成员。

## 动态绑定
**动态绑定只有当通过指针或引用调用虚函数时才会发生**
## 虚函数
当使用基类的引用或指针调用一个虚成员函数时会执行动态绑定
当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数，
调用的函数是与绑定到指针或引用的动态类型相匹配的那一个。

**关键概念：C++的多态性**
OOP的核心思想是多态性。多态性这个词源自希腊语，其含义是"多种形式"。把具有继承关系的多个类型称为多态类型
，因为能够使用这些类型的"多种形式"而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事实正是
C++语言支持多态性的根本所在。

当使用基类的引用或指针调用基类中定义的一个函数时，并不知道该函数真正做用的对象是什么类型，因为它可能是一个
派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型

另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或非虚函数)调用也在编译时绑定。
对象的类型是确定不变得，无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时
绑定到该对象所属类中的函数版本上。

当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
**关键概念：C++的多态性**


### 派生类中的虚函数
+ 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与它被覆盖的基类函数完全一致
+ 派生类中虚函数的返回类型也必须与基类函数匹配
+ 上述规则存在一个例外：当类的虚函数返回类型是类本身的指针或引用时。例如，D由B派生得到，则基类的虚函数可以返回B*，派生类的虚函数可以返回D\*
但是要求从D到B的类型转换是可以访问的。

#### final和override说明符
**override**
编程时，有这样一种错误非常难以调试：
派生类如果定义一个函数与基类中虚函数的名字相同但是形参列表不同，这仍是合法行为，编译器将认为新定义的这个函数与基类中原有的函数相互独立
这时，派生类的函数并没有覆盖掉基类中的版本。就实际的变成习惯而言。这种声明往往意味着发生了错误，因为可能原本希望派生类能覆盖掉基类中的虚函数，
但是一不小心把形参列表弄错了

为了解决上述问题C++11新标准引入了override说明符，在C++11新标准中可以使用override关键字标记某个函数，如果该函数没有覆盖已经存在的虚函数，此时编译器将报错
```cpp
struct B{
  virtual void f1(int) const;
  virtual void f2();
  void f3();
};
struct D1:B{
  void f1(int) const override; //正确，f1与基类中的f1匹配
  void f2(int) override; // 错误，没有形如f2(int)的函数
  void f3() override; // 错误，f3不是虚函数
  void f4() override; // 错误，B没有名为f4函数
}；
```
**final**
把某个函数定义成final，之后任何尝试覆盖该函数的操作都将引发错误
```cpp
struct D2:B{
  // 从B继承f2()和f3(),覆盖f1(int)
  void f1(int) const final; // 不允许后续的其他类覆盖f1(int)
};

struct D3:D2{
  void f2(); //正确：覆盖从间接基类B继承而来的f2
  void f1(int) const;// 错误，D2已经将f2声明为final
};
```

### 虚函数与默认实参
和其它函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则实参的值由本次调用的静态类型决定。

**如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使是实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参**
如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致


## 抽象基类
