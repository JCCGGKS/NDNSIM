# left value
# right value

当一个对象被用作右值时，用的是对象的值(内容)；当对象被用作左值时，用的是对象的身份(在内存中的位置)


一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值(也就是位置)使用
当一个左值被当成右值使用，实际使用的是它的内容(值)

需要用左值的运算符
+ 赋值运算符需要一个(非常量)左值作为其左侧运算对象，得到的结果仍然是一个左值
+ 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值
+ 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值
+ 内置类型和迭代器的递增和递减运算符作用于左值运算对象，前置版本得到的结果是左值

**decltype**
使用关键字decltype时，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式得到一个引用类型
```cpp
int a = 5;
int *p = &a;
decltype(*p) b;//错误，\*p得到的是左值，decltype(\*p)得到的类型是int &，所以b一定要初始化
decltype(&p) c; // 正确，取地址得到的结果是一个右值，c的类型是int **
```

# 对象移动
C++11新标准：移动而非拷贝对象
在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。
使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源(如指针或IO缓冲)。因此，这些类型的对象不能拷贝但可以移动
**标准库容器,string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr可以移动但不能拷贝**
## 右值引用
为了支持移动操作，新标准引入了一种新的引用类型--右值引用(rvalue reference)。右值引用就是必须绑定到右值的引用
通过`&&`获取。
右值引用有一个重要的性质--只能绑定到一个将要销毁的对象，因此可以自由地将一个右值引用的资源移动到另一个对象中。

```cpp
int i=42;
int &r = i; // 正确，对左值的引用
int &&rr = i; // 错误，i是左值不能绑定到对右值的引用
int &r2 = i*42; // 错误，i*42是右值，不能绑定到对左值的引用
int &&rr2 = i*42;// 正确，对右值的引用
const int &r3 = i*42;// 正确,i*42的结果是一个字面常量，可以绑定到指向const int的引用
```
### 左值持久，右值短暂
左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

右值引用只能绑定到临时对象
+ 所引用的对象将要被销毁
+ 该对象没有其它用户
这两个特性意味着：使用右值引用的代码可以自由地接管引用对象的资源

变量表达式都是左值，带来的结果就是，不能将一个右值引用绑定到一个右值引用类型的变量上。
```cpp
int &&rr1 = 42; //正确，右值引用
int &&r2 = rr1;// 错误，rr1是一个左值
```

### 标准库move函数
显式地将一个左值转换为对应的右值引用类型，可以使用std::move()，此函数定义在头文件<<utility>>
```cpp
int &&rr3 = std::move(rr1);//正确
```
#### 理解std::move函数
标准库是这样定义move的
```cpp
template <typename T>
typename remove_reference<T>::type && move(T&& t){
  return static_cast<typename remove_reference<T>::type&&>(t);
}
```
move函数参数T&&是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。即传递左值或右值都是可以的

#### std::move的工作原理
